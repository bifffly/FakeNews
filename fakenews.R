install.packages("devtools")
library(devtools)
# Note: you may need to install package "quadprog" from source here:
# https://cran.rstudio.com/bin/windows/contrib/3.5/quadprog_1.5-5.zip
devtools::install_github("quanteda/quanteda.svm")
library(quanteda.svm)

# Trains an SVM model.
#
# train.dtm: training set
# test.dtm: test set
#
# returns: list containing model and two-way table of results
model.svm <- function(train.dtm, test.dtm) {
  svm.model <- textmodel_svm(train.dtm, y=docvars(train.dtm, "type"))
  pred.svm <- predict(svm.model, newdata=test.dtm, force=T)
  results.svm <- table(prediction=pred.svm, type=docvars(test.dtm, "type"))
  pct <- (results.svm[1, 1] + results.svm[2, 2]) / sum(results.svm)
  return(list(model=svm.model, results=results.svm))
}

# Trains a naive bayes model.
#
# train.dtm: training set
# test.dtm: test set
#
# returns: list containing model and two-way table of results
model.nb <- function(train.dtm, test.dtm) {
  nb.model <- textmodel_nb(train.dtm, y=docvars(train.dtm, "type"))
  pred.nb <- predict(nb.model, newdata=test.dtm, force=T)
  results.nb <- table(prediction=pred.nb, type=docvars(test.dtm, "type"))
  return(list(model=nb.model, results=results.nb))
}

# Creates document-term matrices.
#
# x: data.frame with columns "content" and "type"
# n: number of rows to subset from x
# p: percentage of subset to keep for training set
#
# returns: list containing test and training document-term matrices
create.dtms <- function(x, n, p) {
  subset <- x[sample(1:nrow(x), n/2),]
  dtm <- dfm(subset$content, tolower=T, stem=T, remove=stopwords("english"))
  docvars(dtm, "type") <- subset$type
  train.dtm <- dfm_sample(dtm, p*nrow(subset))
  test.dtm <- dtm[setdiff(docnames(dtm), docnames(train.dtm)),]
  return(list(train=train.dtm, test=test.dtm))
}

# Runs models and aggregates results.
#
# x: data.frame with columns "content" and "type"
# n: number of rows to subset from x
# p: percentage of subset to keep for training set
# i: number of iterations
# model: which model to run
# verbose: prints updates as the function runs
#
# returns: list containing two-way tables of SVM and naive bayes results
iterate <- function(x, n, p, i, model=c("svm", "nb", "both"), verbose=F) {
  results.svm <- table(prediction=c("fake", "fake", "real", "real"), type=c("fake", "real", "fake", "real")) - 1
  results.nb <- results.svm
  for (a in 1:i) {
    if (verbose) {
      cat("iteration ", a, "... ")
    }
    dtms <- create.dtms(x, n, p)
    if (model != "nb") {
      cat("svm ...")
      svm <- model.svm(dtms$train, dtms$test)
      results.svm <- results.svm + svm$results
    }
    if (model != "svm") {
      cat("nb ...")
      nb <- model.nb(dtms$train, dtms$test)
      results.nb <- results.nb + nb$results
    }
    if (verbose) {
      cat("done\n")
    }
  }
  if (model == "nb") {
    return(list(nb=results.nb))
  }
  if (model == "svm") {
    return(list(svm=results.svm))
  }
  else {
    return(list(results=list(svm=results.svm, nb=results.nb), 
                models=list(svm=svm, nb=nb)))
  }
}

# Returns percent correct from two-way tables generated by the iterate function.
#
# table: two-way table
#
# returns: percent correct
pct <- function(table) {
  return((table[1,1] + table[2,2]) / sum(table))
}

# Loads first one million rows of dataset
fnc <- read.csv("~/VT/CMDA3654/Project/Data/big_data.csv", nrows=1000000, stringsAsFactors=F)
fnc <- fnc[-which(fnc$type %in% c("", "unknown")),]
fnc[which(fnc$type %in% c("political", "reliable")), "type"] = "real"
fnc[-which(fnc$type == "real"), "type"] = "fake"
fnc <- fnc[, c("content", "type")]

# Trains model, produces results
results <- iterate(fnc, 1000, 0.7, 1, model="both", verbose=T)

# two-way table for SVM results
results$results$svm
# two-way table for Naive Bayes results
results$results$nb

